#include <iostream>
using namespace std;

typedef int infotype;
typedef struct tNode *addrNode;
typedef struct tNode {
    infotype info;
    addrNode left;
    addrNode right;

}root;

typedef addrNode BinTree;

/* Selektor */
#define Akar(P) (P)->info
#define Left(P) (P)->left
#define Right(P) (P)->right

#define Nil NULL

BinTree Tree (infotype Akar, BinTree L, BinTree R){
/* Menghasilkan sebuah pohon biner dari A, L, dan R, jika
   alokasi berhasil */
/* Menghasilkan pohon kosong (Nil) jika alokasi gagal */ 

}

addrNode AlokNode (infotype X){
/* Mengirimkan addrNode hasil alokasi sebuah elemen */
/* Jika alokasi berhasil, maka addrNode tidak Nil, dan
   misalnya menghasilkan P,
   maka Akar(P) = X, Left(P) = Nil, Right(P)=Nil */
/* Jika alokasi gagal, mengirimkan Nil */
}
 
void DealokNode (addrNode P){
/* I.S. P terdefinisi */
/* F.S. P dikembalikan ke sistem */
/* Melakukan dealokasi/pengembalian addrNode P */
}

bool IsTreeEmpty (BinTree P)
/* Mengirimkan true jika P adalah pohon biner kosong */
{   /* Kamus Lokal */
    /* Algoritma */
    return (P == Nil);
}
bool IsTreeOneElmt (BinTree P)
/* Mengirimkan true jika P adalah pohon biner tidak kosong
   dan hanya memiliki 1 elemen */
{   /* Kamus Lokal */
    /* Algoritma */
    if (P != Nil) {
        return (Left(P) == Nil && Right(P) == Nil);
    } else { /* Pohon kosong */
        return false;
    }
}

bool IsUnerLeft (BinTree P)
/* Mengirimkan true jika pohon biner tidak kosong
   P adalah pohon unerleft: hanya mempunyai subpohon kiri */
{   /* Kamus Lokal */
    /* Algoritma */
    if (P != Nil) {
        return (Left(P) != Nil && Right(P) == Nil);
    } else { /* Pohon kosong */
        return false;
    }
}

bool IsUnerRight (BinTree P)
/* Mengirimkan true jika pohon biner tidak kosong P adalah pohon
   unerright: hanya mempunyai subpohon kanan*/
{   /* Kamus Lokal */
    /* Algoritma */
    if (P != Nil) {
        return (Left(P) == Nil && Right(P) != Nil);
    } else { /* Pohon kosong */
        return false;
    }
}

bool IsBiner (BinTree P)
/* Mengirimkan true jika pohon biner tidak kosong
   P adalah pohon biner: mempunyai subpohon kiri dan subpohon kanan*/
{   /* Kamus Lokal */
    /* Algoritma */
    if (P != Nil) {
        return (Left(P) != Nil && Right(P) != Nil);
    } else { /* Pohon kosong */
        return false;
    }
}

void AddDaunTerkiri (BinTree *P, infotype X)
/* I.S. P boleh kosong */
/* F.S. P bertambah simpulnya,
        dengan X sebagai simpul daun terkiri */
{   /* Kamus Lokal */
    /* Algoritma */
    if (IsTreeEmpty(*P)) { /* Basis-0 */
        *P = Tree(X,Nil,Nil);
    } else {              /* Rekurens */
        AddDaunTerkiri(&(Left(*P)),X);
    }
}

void AddDaunTerkanan (BinTree *P, infotype X)
/* I.S. P boleh kosong */
/* F.S. P bertambah simpulnya,
        dengan X sebagai simpul daun terkiri */
{   /* Kamus Lokal */
    /* Algoritma */
    if (IsTreeEmpty(*P)) { /* Basis-0 */
        *P = Tree(X,Nil,Nil);
    } else {              /* Rekurens */
        AddDaunTerkanan(&(Right(*P)),X);
    }
}

int main (){


    }
